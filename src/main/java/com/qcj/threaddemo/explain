实现线程的三种方式
1.实现runable
2.继承Thread
3.重写callable接口重写call方法
    1.5后，返回一个参数
https://blog.csdn.net/lx_Frolf/article/details/82318736
https://blog.csdn.net/qq_33666932/article/details/79371826


线程和进程：
        进程：
			占用计算机一定的cpu   内存  带宽  等资源的一个应用
			.exe    qq
			一个操作系统包括多个进程
		线程：
			qq----进程   一定的资源
				qq同时和多个人进行聊天的时候   相互独立的
				多线程
			一个进程包含多个线程
线程创建的方式：
			两种方式：
				1）extends Thread(){
					run()//线程需要执行的代码
				}
				2)implements Runnable(){
				}

				方式2：更好
					单继承   多实现
				线程启动的方式：
					start()
start()  和  run()区别
				start  线程启动的方法，启动线程的时候会调用run方法
				run（） 线程中的普通的方法  调用这个方法的时候不会启动新的线程  仅仅是一个普通方法的调用
线程的状态：
			新建  就绪   运行   阻塞   死亡
			start()   启动线程
				不一定运行的     jvm分配时间片
造成阻塞的方式：https://blog.csdn.net/weixin_41101173/article/details/79679300
    （1）线程睡眠：Thread.sleep (long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
    （2）线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait() 一样。wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.
    （3）线程礼让，Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.
    （4）线程自闭，join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
    （5）suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。
sleep 和 wait？
    1. sleep(毫秒)
       放弃CPU的执行权；
       但是不会放弃锁;
    2.wait(可选)
      放弃CPU的执行权；
       但是会放弃锁;
线程锁：
			同步锁
				synchronized  线程同步锁关键字
				应用场景：
					多线程并发  需要操作临界资源的时候  会使用线程同步锁
					目的：就是保证共享资源的安全性
					临界资源：多线程需要共同操作的变量
						抢票     100    3线程
						每次只能允许一个线程操作  共享资源（临界资源）
						一个线程抢到了   票数没有来得及-
						这个时候我们就可以通过  线程同步锁
						性能比较低的
				锁对象的要求：
					必须全局唯一的     多个线程之间  操作临界资源的时候 必须锁的是同一个对象   同一把锁同一时间只能允许一个线程获取对象
					thread-1    锁  “sb”
					thread-2   锁   “sb”   ----同一个对象

					this-------锁的当前的对象

					t1----“sb”----常量池中
					t2------new String("sb") ----不是同一个对象


					t1------new String("sb")
					t2------new String("sb")-----不是同一个对象
				锁获取：不是人为决定的
					jvm决定的
				锁释放：
					jvm决定的
					1.执行完成所有代码
					2.抛异常的时候
				使用范围：
					锁方法------这个方法同一时间只能允许  一个线程操作
					锁代码块----这个代码块同一时间只能允许  一个线程操作

			lock：接口
				void lock();    锁    阻塞方法   阻塞的时间：另外一个线程释放锁
					手动添加锁的方法
				boolean tryLock();   试图获取锁的方法
					返回值   boolean    非阻塞方法
					线程启动的时候  会尝试的获取锁  获取到---true  获取不到--false
				boolean tryLock(5, m) throws InterruptedException;   试图获取锁的方法   参数1：参数时间大小   参数2：时间单位
					阻塞方法   阻塞的时间就是参数的时间
					参数的时间内  获取到了---true  获取不到---false
				void lockInterruptibly() throws InterruptedException;
				 	lock    锁
				 	Interrupt  中断
				 	bly   具备。。。能力
				 	使锁具备可被中断的能力
				 	防止死等
				 	中断在等待中的锁
				unlock：   是释放锁

				手动添加锁
				锁的添加   代码中
				锁的释放：
					一定需要手动释放  如果不手动释放  即使代码中抛异常了也不会释放锁   必须手动释放
					一般我们的这种的锁释放  finally中
				integer.max 最大是后释放 2100000s000（大约21亿毫秒）

            死锁是需要避免的问题
        死锁产生的条件：
                互斥条件：一个资源每次只能被一个进程使用。
                请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
                不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
                循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

读写锁：
				读锁-----写    冲突
				读-----读     可以的
				写----写    冲突的
				读锁：共享锁
					同一时间可以允许多个线程  共同访问的
				写锁：排他锁
					同一时间  只能允许一个线程进行操作
				假设2个线程：
					线程1  获取到了读锁
						线程2：
						获取读锁----可以获取到的
						获取写锁----不能获取   必须等待线程1的读锁释放才能获取
					线程1   获取了写锁：
						线程2：
						获取读锁  ---  不能   必须等线程1的写锁释放
						获取写锁----不能的   必须等待线程1的写锁释放
				读写锁的实现：
					ReadWriteLock  接口层
						ReentrantReadWriteLock   实现类
							//获取写锁对象的  返回值  写锁对象
						    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
						    	如何加锁：lock
						    //获取读锁对象的   返回值  读锁对象
    						public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
几个关键字：volatile（指令重排） atomic（原子性） threadLocal(本地线程变量)
    		Volatile java中的内置关键字：
    			jvm操作变量的时候  3个特点：
    			1.原子性
    				不可分割的操作----  数据库中的事物
    				一个操作要么成功  要么失败   这个操作就是原子性的操作
    				原子性：
    					赋值操作
    					int i=5;//原子性的操作
    					int b=i;
    					数学运算
    				i++   非原子性的操作
    					i=i+1
    					i+1  进行加
    					i=i+1  进行复制操作
    				i--    非原子性的操作
    			2.可见性（内存可见性）:
    				jvm对变量进行操作的时候  多线程之间相互访问的时候 可以访问一个线程内存中的数据       内存可见性
    				jvm内存：
    					堆：对象  new   全局变量
    					栈：地址
    				一个线程可以访问另外一个线程的  对全局变量的操作的中间的内存结果
    			3.指令重拍
    				main{
						int a=5;
						int b=3;
						int c=a+b;
    				}
    				在进行底层代码的编译的过程中 有可能会对原来的顺序做一个调整
    					b=3
    					a=5
    					a+b
    		Volatile：保证变量操作的时候  可见性  指令重拍  不保证原子性
    			作用：
    				用于多线程之间的状态的交换
    	想要保证原子性的操作：
    		1）synchronize   同步锁      性能太低
    		2）atomicXXX 保证原子性操作  又不至于性能过低
    		atomicInteger   保证原子操作的int类型
    		atomicLong      保证原子操作的long类型
    		原子性操作的类
    	本地线程变量：
    		threadlocal:
    		本地线程副本  ----   备份   在副本中 所有的备份和原始文件都是同等地位的   没有任何主次之分的
    		int i;
    		i=1;
    		应用场景：
    			本地的变量   创建出来多个副本  每个线程只取其中一个副本操作
    			应用在一些对象比较难初始化的变量上（初始化的时候耗时过长  初始化的时候做的事情过多）  需要多个线程使用的
    			为了避每个线进行操作的时候都初始化这个对象  可以使用本地线程副本  相当于直接初始化一次  进行复制的工作
    			tomcat   3-8s

